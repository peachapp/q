import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o,f as c}from"./app-C4tUi4gM.js";const a={},d=c('<h1 id="keep-alive" tabindex="-1"><a class="header-anchor" href="#keep-alive"><span><code>keep alive</code></span></a></h1><p><code>keep alive</code>是<code>vue</code>自带的一个组件，是用来缓存组件的，使组件不会被销毁（保留组件状态或避免重新渲染），以此来提升性能。</p><p>用法：</p><p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<code>&lt;transition&gt;</code>相似，<code>&lt;keep-alive&gt;</code>是一个抽象组件，它自身不会渲染一个<code>DOM元素</code>，也不会出现在组件的父组件链中。当组件在<code>&lt;keep-alive&gt;</code>内被切换时，它的<code>mounted</code>和<code>unmounted</code>生命周期钩子不会被调用，取而代之的是<code>activated</code>和<code>deactivated</code>（这会运用在<code>&lt;keep-alive&gt;</code>的直接子节点及其所有子孙节点）。</p><p>使用场景：</p><p>就是来缓存组件，提升项目的性能。具体实现比如：首页进入到详情页，如果用户在首页每次点击都是相同的，那么详情页就没必要请求<code>n</code>次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就直接请求。</p>',6),i=[d];function p(n,l){return o(),t("div",null,i)}const s=e(a,[["render",p],["__file","keep alive.html.vue"]]),v=JSON.parse('{"path":"/VUE/keep%20alive.html","title":"keep alive","lang":"zh-CN","frontmatter":{"description":"keep alive keep alive是vue自带的一个组件，是用来缓存组件的，使组件不会被销毁（保留组件状态或避免重新渲染），以此来提升性能。 用法： <keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<transition>相似，<keep-alive>是一个抽象组件，它自身不会渲染一个DOM元素，也不会出现在组...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/VUE/keep%20alive.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"keep alive"}],["meta",{"property":"og:description","content":"keep alive keep alive是vue自带的一个组件，是用来缓存组件的，使组件不会被销毁（保留组件状态或避免重新渲染），以此来提升性能。 用法： <keep-alive>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<transition>相似，<keep-alive>是一个抽象组件，它自身不会渲染一个DOM元素，也不会出现在组..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-20T06:06:03.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-20T06:06:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"keep alive\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-20T06:06:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1723794615000,"updatedTime":1724133963000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":1}]},"readingTime":{"minutes":0.88,"words":265},"filePathRelative":"VUE/keep alive.md","localizedDate":"2024年8月16日","excerpt":"\\n<p><code>keep alive</code>是<code>vue</code>自带的一个组件，是用来缓存组件的，使组件不会被销毁（保留组件状态或避免重新渲染），以此来提升性能。</p>\\n<p>用法：</p>\\n<p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和<code>&lt;transition&gt;</code>相似，<code>&lt;keep-alive&gt;</code>是一个抽象组件，它自身不会渲染一个<code>DOM元素</code>，也不会出现在组件的父组件链中。当组件在<code>&lt;keep-alive&gt;</code>内被切换时，它的<code>mounted</code>和<code>unmounted</code>生命周期钩子不会被调用，取而代之的是<code>activated</code>和<code>deactivated</code>（这会运用在<code>&lt;keep-alive&gt;</code>的直接子节点及其所有子孙节点）。</p>","autoDesc":true}');export{s as comp,v as data};
