import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as d,f as l}from"./app-8HN3oAmX.js";const c={},i=l('<h1 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span><code>Promise</code></span></a></h1><h2 id="promise-1" tabindex="-1"><a class="header-anchor" href="#promise-1"><span><code>Promise</code></span></a></h2><p><code>Promise</code>是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理且更强大。它最早由社区提出并实现，<code>ES6</code>将其写进了语言标准，统一了用法，并原生提供了<code>Promise</code>对象。</p><p>特点：</p><ol><li>对象的状态不受外界影响（三种状态）</li></ol><ul><li><code>Pending</code>状态（进行中）</li><li><code>Fulfilled</code>状态（已成功）</li><li><code>Rejected</code>状态（已失败）</li></ul><ol start="2"><li>一旦状态改变就不会再变（两种状态改变：成功或失败）。</li></ol><ul><li><code>Pending</code> --&gt; <code>Fulfilled</code></li><li><code>Pending</code> --&gt; <code>Rejected</code></li></ul><p>用法：</p><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code>引擎提供，不用自己部署。</p><p><code>resolve</code>作用是将<code>Promise</code>对象状态由“未完成”变为“成功”，也就是<code>Pending</code> --&gt; <code>Fulfilled</code>，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；而<code>reject</code>函数则是将<code>Promise</code>对象状态由“未完成”变为“失败”，也就是<code>Pending</code> --&gt; <code>Rejected</code>，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。</p><p><code>Promise</code>实例生成后，可用<code>then</code>方法分别指定两种状态回调参数。<code>then</code>方法可以接受两个回调函数作为参数：</p><ol><li><code>Promise</code>对象状态改为<code>Fulfilled</code>时调用（必选）。</li><li><code>Promise</code>对象状态改为<code>Rejected</code>时调用（可选）。</li></ol><p>优缺点：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>解决回调</td><td>无法监测进行状态</td></tr><tr><td>链式调用</td><td>新建立即执行且无法取消</td></tr><tr><td>减少嵌套</td><td>内部错误无法抛出</td></tr></tbody></table><p><code>Promise</code>是干什么的？</p><ol><li>主要用于异步计算。</li><li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。</li><li>可以在对象之间传递和操作<code>Promise</code>，帮助我们处理队列。</li></ol><h2 id="promise-all和promise-allsettled" tabindex="-1"><a class="header-anchor" href="#promise-all和promise-allsettled"><span><code>Promise.all</code>和<code>Promise.allSettled</code></span></a></h2><ul><li><code>Promise.all</code>需要所有<code>promise</code>都成功时才<code>resolve</code>或者有一个失败时即<code>reject</code>。</li><li><code>Promise.allSettled</code>方法返回一个在所有给定的<code>promise</code>都已经<code>fulfilled</code>或<code>rejected</code>后的<code>promise</code>，并带有一个对象数组，每个对象表示对应的<code>promise</code>结果。</li></ul><h2 id="解决promise-all-只要失败一个就不会走then" tabindex="-1"><a class="header-anchor" href="#解决promise-all-只要失败一个就不会走then"><span>解决<code>Promise.all</code>（只要失败一个就不会走<code>then</code>）</span></a></h2><ol><li><code>Promise.allSettled</code>。</li><li><code>try catch</code>包裹，如果成功，调用<code>resolve</code>，如果失败<code>catch</code>到错误，调用<code>Promise.resolve</code>。</li></ol><h2 id="如何让一个函数无论promise对象成功和失败都能被调用" tabindex="-1"><a class="header-anchor" href="#如何让一个函数无论promise对象成功和失败都能被调用"><span>如何让一个函数无论<code>promise</code>对象成功和失败都能被调用</span></a></h2><ol><li>在<code>finally</code>中调用这个函数。</li><li><code>resolve</code>和<code>reject</code>中分别调用这个函数。</li></ol>',23),t=[i];function r(s,a){return d(),o("div",null,t)}const p=e(c,[["render",r],["__file","promise.html.vue"]]),h=JSON.parse('{"path":"/JAVASCRIPT/promise.html","title":"Promise","lang":"zh-CN","frontmatter":{"description":"Promise Promise Promise是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 特点： 对象的状态不受外界影响（三种状态） Pending状态（进行中） Fulfilled状态（已成功） Rejected状态（已失败...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/JAVASCRIPT/promise.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"Promise"}],["meta",{"property":"og:description","content":"Promise Promise Promise是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理且更强大。它最早由社区提出并实现，ES6将其写进了语言标准，统一了用法，并原生提供了Promise对象。 特点： 对象的状态不受外界影响（三种状态） Pending状态（进行中） Fulfilled状态（已成功） Rejected状态（已失败..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-20T06:06:03.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-20T06:06:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Promise\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-20T06:06:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Promise","slug":"promise-1","link":"#promise-1","children":[]},{"level":2,"title":"Promise.all和Promise.allSettled","slug":"promise-all和promise-allsettled","link":"#promise-all和promise-allsettled","children":[]},{"level":2,"title":"解决Promise.all（只要失败一个就不会走then）","slug":"解决promise-all-只要失败一个就不会走then","link":"#解决promise-all-只要失败一个就不会走then","children":[]},{"level":2,"title":"如何让一个函数无论promise对象成功和失败都能被调用","slug":"如何让一个函数无论promise对象成功和失败都能被调用","link":"#如何让一个函数无论promise对象成功和失败都能被调用","children":[]}],"git":{"createdTime":1723009479000,"updatedTime":1724133963000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":1}]},"readingTime":{"minutes":2.07,"words":620},"filePathRelative":"JAVASCRIPT/promise.md","localizedDate":"2024年8月7日","excerpt":"\\n<h2><code>Promise</code></h2>\\n<p><code>Promise</code>是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理且更强大。它最早由社区提出并实现，<code>ES6</code>将其写进了语言标准，统一了用法，并原生提供了<code>Promise</code>对象。</p>\\n<p>特点：</p>\\n<ol>\\n<li>对象的状态不受外界影响（三种状态）</li>\\n</ol>\\n<ul>\\n<li><code>Pending</code>状态（进行中）</li>\\n<li><code>Fulfilled</code>状态（已成功）</li>\\n<li><code>Rejected</code>状态（已失败）</li>\\n</ul>","autoDesc":true}');export{p as comp,h as data};
