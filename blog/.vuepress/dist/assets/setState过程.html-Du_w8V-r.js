import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o,f as c}from"./app-C4tUi4gM.js";const d="/assets/0001-B2Hf0Rvn.png",a={},n=c('<h1 id="setstate过程" tabindex="-1"><a class="header-anchor" href="#setstate过程"><span><code>setState</code>过程</span></a></h1><p><code>setState</code>之后发生了什么？</p><p><strong>简单版本：</strong><code>react</code>利用状态队列机制实现了<code>setState</code>的“异步”更新，避免频繁的重复更新<code>state</code>。</p><p>首先将新的<code>state</code>合并到状态更新队列中，然后根据更新队列和<code>shouldComponentUpdate</code>的状态来判断是否需要更新组件。</p><p><strong>复杂版本：</strong></p><ul><li><code>enqueueSetState</code>将<code>state</code>放入队列中，并调用<code>enqueueUpdate</code>处理要更新的<code>Component</code></li><li>如果组件当前正处于<code>update</code>事务中，则先将<code>Component</code>存入<code>dirtyComponent</code>中。否则调用<code>batchedUpdates</code>处理。</li><li><code>batchedUpdates</code>发起一次<code>transaction.perform()</code>事务</li><li>开始执行事务初始化，运行，结束三个阶段 <ul><li>初始化：事务初始化阶段没有注册方法，故无方法要执行</li><li>运行：执行<code>setSate</code>时传入的<code>callback</code>方法</li><li>结束：更新<code>isBatchingUpdates</code>为<code>false</code>，并执行<code>FLUSH_BATCHED_UPDATES</code>这个<code>wrapper</code>中的<code>close</code>方法<code>FLUSH_BATCHED_UPDATES</code>在<code>close</code>阶段，会循环遍历所有的<code>dirtyComponents</code>，调用<code>updateComponent</code>刷新组件，并执行它的<code>pendingCallbacks</code>, 也就是<code>setState</code>中设置的<code>callback</code>。</li></ul></li></ul><p><a href="https://juejin.cn/post/6844903781813993486#heading-9" target="_blank" rel="noopener noreferrer">参考文章</a></p><ol><li>将<code>setState</code>传入的<code>partialState</code>参数存储在当前组件实例的<code>state</code>暂存队列中。</li><li>判断当前<code>React</code>是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li><li>如果未处于批量更新状态，将批量更新状态标识设置为<code>true</code>，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li><li>调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</li><li>执行生命周期<code>componentWillReceiveProps</code>。</li><li>将组件的<code>state</code>与暂存队列中的<code>state</code>进行合并，获得最终要更新的<code>state</code>对象，并将队列置为空。</li><li>执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li><li>执行生命周期<code>componentWillUpdate</code>。</li><li>执行真正的更新，<code>render</code>。</li><li>执行生命周期<code>componentDidUpdate</code>。</li></ol><figure><img src="'+d+'" alt="setState执行流程图" tabindex="0" loading="lazy"><figcaption>setState执行流程图</figcaption></figure>',9),s=[n];function l(i,p){return o(),t("div",null,s)}const u=e(a,[["render",l],["__file","setState过程.html.vue"]]),S=JSON.parse('{"path":"/REACT/setState%E8%BF%87%E7%A8%8B.html","title":"setState过程","lang":"zh-CN","frontmatter":{"description":"setState过程 setState之后发生了什么？ 简单版本： react利用状态队列机制实现了setState的“异步”更新，避免频繁的重复更新state。 首先将新的state合并到状态更新队列中，然后根据更新队列和shouldComponentUpdate的状态来判断是否需要更新组件。 复杂版本： enqueueSetState将state放...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/REACT/setState%E8%BF%87%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"setState过程"}],["meta",{"property":"og:description","content":"setState过程 setState之后发生了什么？ 简单版本： react利用状态队列机制实现了setState的“异步”更新，避免频繁的重复更新state。 首先将新的state合并到状态更新队列中，然后根据更新队列和shouldComponentUpdate的状态来判断是否需要更新组件。 复杂版本： enqueueSetState将state放..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"🍑"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"setState过程\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.65,"words":494},"filePathRelative":"REACT/setState过程.md","excerpt":"\\n<p><code>setState</code>之后发生了什么？</p>\\n<p><strong>简单版本：</strong>\\n<code>react</code>利用状态队列机制实现了<code>setState</code>的“异步”更新，避免频繁的重复更新<code>state</code>。</p>\\n<p>首先将新的<code>state</code>合并到状态更新队列中，然后根据更新队列和<code>shouldComponentUpdate</code>的状态来判断是否需要更新组件。</p>\\n<p><strong>复杂版本：</strong></p>\\n<ul>\\n<li><code>enqueueSetState</code>将<code>state</code>放入队列中，并调用<code>enqueueUpdate</code>处理要更新的<code>Component</code></li>\\n<li>如果组件当前正处于<code>update</code>事务中，则先将<code>Component</code>存入<code>dirtyComponent</code>中。否则调用<code>batchedUpdates</code>处理。</li>\\n<li><code>batchedUpdates</code>发起一次<code>transaction.perform()</code>事务</li>\\n<li>开始执行事务初始化，运行，结束三个阶段\\n<ul>\\n<li>初始化：事务初始化阶段没有注册方法，故无方法要执行</li>\\n<li>运行：执行<code>setSate</code>时传入的<code>callback</code>方法</li>\\n<li>结束：更新<code>isBatchingUpdates</code>为<code>false</code>，并执行<code>FLUSH_BATCHED_UPDATES</code>这个<code>wrapper</code>中的<code>close</code>方法<code>FLUSH_BATCHED_UPDATES</code>在<code>close</code>阶段，会循环遍历所有的<code>dirtyComponents</code>，调用<code>updateComponent</code>刷新组件，并执行它的<code>pendingCallbacks</code>, 也就是<code>setState</code>中设置的<code>callback</code>。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{u as comp,S as data};
