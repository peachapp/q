import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o,f as c}from"./app-C4tUi4gM.js";const n={},a=c('<h1 id="暂时性死区" tabindex="-1"><a class="header-anchor" href="#暂时性死区"><span>暂时性死区</span></a></h1><blockquote><p>当程序的控制流程在新的作用域进行实例化时，在此作用域中的<code>let/const</code>声明的变量，会先在作用域中创建出来，但此时还未在词法环境中进行注册（没有词法绑定），所以此时是不能被访问的，访问就会报错。</p></blockquote><blockquote><p>从创建变量到可以被访问这一期间，叫做暂时性死区。</p></blockquote><p>暂时性死区究其原因还是没有先声明后使用，解决办法就是要先声明后使用，否则就会引发暂时性死区。</p><p>暂时性死区的本质是：只要一进入当前作用域，所使用的变量就已经存在了，但是不可获取。只有等到<code>let</code>、<code>const</code>声明变量的那一行代码出现，才能获取和使用该变量。</p><ul><li><code>let</code>、<code>const</code>、<code>import</code>、<code>class</code>、<code>typeof</code>都会出现暂时性死区。</li><li><code>var</code>、<code>function</code>不会出现暂时性死区。</li></ul>',6),r=[a];function p(d,i){return o(),t("div",null,r)}const m=e(n,[["render",p],["__file","暂时性死区.html.vue"]]),h=JSON.parse('{"path":"/JAVASCRIPT/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA.html","title":"暂时性死区","lang":"zh-CN","frontmatter":{"description":"暂时性死区 当程序的控制流程在新的作用域进行实例化时，在此作用域中的let/const声明的变量，会先在作用域中创建出来，但此时还未在词法环境中进行注册（没有词法绑定），所以此时是不能被访问的，访问就会报错。 从创建变量到可以被访问这一期间，叫做暂时性死区。 暂时性死区究其原因还是没有先声明后使用，解决办法就是要先声明后使用，否则就会引发暂时性死区。 ...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/JAVASCRIPT/%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"暂时性死区"}],["meta",{"property":"og:description","content":"暂时性死区 当程序的控制流程在新的作用域进行实例化时，在此作用域中的let/const声明的变量，会先在作用域中创建出来，但此时还未在词法环境中进行注册（没有词法绑定），所以此时是不能被访问的，访问就会报错。 从创建变量到可以被访问这一期间，叫做暂时性死区。 暂时性死区究其原因还是没有先声明后使用，解决办法就是要先声明后使用，否则就会引发暂时性死区。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-20T06:06:03.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-20T06:06:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"暂时性死区\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-20T06:06:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1723009479000,"updatedTime":1724133963000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":1}]},"readingTime":{"minutes":0.81,"words":242},"filePathRelative":"JAVASCRIPT/暂时性死区.md","localizedDate":"2024年8月7日","excerpt":"\\n<blockquote>\\n<p>当程序的控制流程在新的作用域进行实例化时，在此作用域中的<code>let/const</code>声明的变量，会先在作用域中创建出来，但此时还未在词法环境中进行注册（没有词法绑定），所以此时是不能被访问的，访问就会报错。</p>\\n</blockquote>\\n<blockquote>\\n<p>从创建变量到可以被访问这一期间，叫做暂时性死区。</p>\\n</blockquote>\\n<p>暂时性死区究其原因还是没有先声明后使用，解决办法就是要先声明后使用，否则就会引发暂时性死区。</p>\\n<p>暂时性死区的本质是：只要一进入当前作用域，所使用的变量就已经存在了，但是不可获取。只有等到<code>let</code>、<code>const</code>声明变量的那一行代码出现，才能获取和使用该变量。</p>","autoDesc":true}');export{m as comp,h as data};
