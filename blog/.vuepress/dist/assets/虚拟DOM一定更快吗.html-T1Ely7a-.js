import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,f as d}from"./app-C4tUi4gM.js";const t={},r=d('<h1 id="虚拟dom一定更快吗" tabindex="-1"><a class="header-anchor" href="#虚拟dom一定更快吗"><span>虚拟<code>DOM</code>一定更快吗</span></a></h1><ol><li>初次渲染的时候，其实并不快。</li><li>在更新的时候，更新的元素内容比较少，它可以实现精准的定量更新，不需把全部的<code>DOM</code>元素删除重添加。</li><li>虚拟<code>DOM</code>的优势肯定不是更快，而是：跨平台、增量更新、处理兼容性问题...。</li></ol><p><code>react</code>中涉及到虚拟<code>DOM</code>的代码主要分为以下三部分，其中核心是第二步的<code>domDiff</code>算法：</p><ul><li>把<code>render</code>中的<code>JSX</code>（或者<code>createElement</code>这个<code>API</code>）转化成虚拟<code>DOM</code>。</li><li>状态或属性改变后重新计算虚拟<code>DOM</code>并生成一个补丁对象 (<code>domDiff</code>)。</li><li>通过这个补丁对象更新视图中的<code>DOM</code>节点。</li></ul><p><code>DOM</code>操作是性能杀手，因为操作<code>DOM</code>会引起页面的回流或者重绘。相比起来，通过多一些预先计算来减少<code>DOM</code>的操作要划算的多。</p><p>但是，“使用虚拟<code>DOM</code>会更快”这句话并不一定适用于所有场景。例如：一个页面就有一个按钮，点击一下，数字加一，那肯定是直接操作<code>DOM</code>更快。使用虚拟<code>DOM</code>无非白白增加了计算量和代码量。即使是复杂情况，浏览器也会对我们的<code>DOM</code>操作进行优化，大部分浏览器会根据我们操作的时间和次数进行批量处理，所以直接操作<code>DOM</code>也未必很慢。</p><p>那么为什么现在的框架都使用虚拟<code>DOM</code>呢？因为使用虚拟<code>DOM</code>可以提高代码的性能下限，并极大的优化大量操作<code>DOM</code>时产生的性能损耗。同时这些框架也保证了，即使在少数虚拟<code>DOM</code>不太给力的场景下，性能也在我们接受的范围内。</p><p>而且，我们之所以喜欢<code>react</code>、<code>vue</code>等使用了虚拟<code>DOM</code>的框架，不光是因为他们快，还有很多其他更重要的原因。例如<code>react</code>对函数式编程的友好，<code>vue</code>优秀的开发体验等。</p>',8),i=[r];function l(n,a){return c(),o("div",null,i)}const M=e(t,[["render",l],["__file","虚拟DOM一定更快吗.html.vue"]]),O=JSON.parse('{"path":"/REACT/%E8%99%9A%E6%8B%9FDOM%E4%B8%80%E5%AE%9A%E6%9B%B4%E5%BF%AB%E5%90%97.html","title":"虚拟DOM一定更快吗","lang":"zh-CN","frontmatter":{"description":"虚拟DOM一定更快吗 初次渲染的时候，其实并不快。 在更新的时候，更新的元素内容比较少，它可以实现精准的定量更新，不需把全部的DOM元素删除重添加。 虚拟DOM的优势肯定不是更快，而是：跨平台、增量更新、处理兼容性问题...。 react中涉及到虚拟DOM的代码主要分为以下三部分，其中核心是第二步的domDiff算法： 把render中的JSX（或者c...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/REACT/%E8%99%9A%E6%8B%9FDOM%E4%B8%80%E5%AE%9A%E6%9B%B4%E5%BF%AB%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"虚拟DOM一定更快吗"}],["meta",{"property":"og:description","content":"虚拟DOM一定更快吗 初次渲染的时候，其实并不快。 在更新的时候，更新的元素内容比较少，它可以实现精准的定量更新，不需把全部的DOM元素删除重添加。 虚拟DOM的优势肯定不是更快，而是：跨平台、增量更新、处理兼容性问题...。 react中涉及到虚拟DOM的代码主要分为以下三部分，其中核心是第二步的domDiff算法： 把render中的JSX（或者c..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"🍑"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"虚拟DOM一定更快吗\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.74,"words":523},"filePathRelative":"REACT/虚拟DOM一定更快吗.md","excerpt":"\\n<ol>\\n<li>初次渲染的时候，其实并不快。</li>\\n<li>在更新的时候，更新的元素内容比较少，它可以实现精准的定量更新，不需把全部的<code>DOM</code>元素删除重添加。</li>\\n<li>虚拟<code>DOM</code>的优势肯定不是更快，而是：跨平台、增量更新、处理兼容性问题...。</li>\\n</ol>\\n<p><code>react</code>中涉及到虚拟<code>DOM</code>的代码主要分为以下三部分，其中核心是第二步的<code>domDiff</code>算法：</p>\\n<ul>\\n<li>把<code>render</code>中的<code>JSX</code>（或者<code>createElement</code>这个<code>API</code>）转化成虚拟<code>DOM</code>。</li>\\n<li>状态或属性改变后重新计算虚拟<code>DOM</code>并生成一个补丁对象 (<code>domDiff</code>)。</li>\\n<li>通过这个补丁对象更新视图中的<code>DOM</code>节点。</li>\\n</ul>","autoDesc":true}');export{M as comp,O as data};
