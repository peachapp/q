import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o,f as c}from"./app-8HN3oAmX.js";const a={},s=c(`<h1 id="清除浮动" tabindex="-1"><a class="header-anchor" href="#清除浮动"><span>清除浮动</span></a></h1><h2 id="需要清除浮动的原因" tabindex="-1"><a class="header-anchor" href="#需要清除浮动的原因"><span>需要清除浮动的原因</span></a></h2><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现为该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“<code>高度塌陷</code>”。</p><p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><h2 id="清除浮动的方式" tabindex="-1"><a class="header-anchor" href="#清除浮动的方式"><span>清除浮动的方式</span></a></h2><ol><li>使用<code>clear</code>属性清除浮动。</li><li>使用<code>BFC</code>块级格式化上下文来清除浮动。</li></ol><p>因为<code>BFC</code>元素具有不会影响外部元素的特点，所以<code>BFC</code>元素也可以用来清除浮动的影响。因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违<code>BFC</code>元素的子元素不会影响外部元素的设定。</p><h2 id="使用clear属性清除浮动的原理" tabindex="-1"><a class="header-anchor" href="#使用clear属性清除浮动的原理"><span>使用<code>clear</code>属性清除浮动的原理</span></a></h2><p>使用<code>clear</code>属性清除浮动，其语法如下：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">clear: none|left|right|both;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果单看字面意思，<code>clear: left;</code>应该是“清除左浮动”，<code>clear: right;</code>应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对<code>clear</code>属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置<code>clear</code>属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意的一点是<code>clear</code>属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<code>前面的</code>”三个字，也就是<code>clear</code>属性对“后面的”浮动元素是不闻不问的。考虑到<code>float</code>属性要么是<code>left</code>，要么是<code>right</code>，不可能同时存在，同时由于<code>clear</code>属性对“后面的”浮动元素不闻不问，因此，当<code>clear: left;</code>有效的时候，<code>clear: right;</code>必定无效，也就是此时<code>clear: left;</code>等同于设置<code>clear: both;</code>同样地，<code>clear: right;</code>如果有效也是等同于设置<code>clear: both;</code>。由此可见，<code>clear: left;</code>和<code>clear: right;</code>这两个声明就没有任何使用的价值，至少在<code>CSS</code>世界中是如此，直接使用<code>clear: both;</code>吧。</p><p>一般使用伪元素的方式清除浮动：</p><div class="language-css line-numbers-mode" data-highlighter="shiki" data-ext="css" data-title="css" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">.clear</span><span style="--shiki-light:#986801;--shiki-dark:#56B6C2;">::after</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  content: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  display: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; // 也可以是&#39;block&#39;，或者是&#39;list-item&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  clear: </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">both</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>clear</code>属性只有块级元素才有效的，而<code>::after</code>等伪元素默认都是行内元素，这就是借助伪元素清除浮动影响时需要设置<code>display</code>属性值的原因。</p><h2 id="zoom-1清除浮动的原理" tabindex="-1"><a class="header-anchor" href="#zoom-1清除浮动的原理"><span><code>zoom:1</code>清除浮动的原理</span></a></h2><p>清除浮动，触发<code>hasLayout</code>。</p><p><code>zoom</code>属性可以设置或检索对象的缩放比例。解决<code>IE</code>下比较奇葩的<code>bug</code>。譬如外边距（<code>margin</code>）的重叠，浮动清除，触发<code>IE</code>的<code>hasLayout</code>属性等。</p><p>来龙去脉大概如下：当设置了<code>zoom</code>的值之后，所设置的元素就会扩大或者缩小，高度宽度就会重新计算，这里一旦改变<code>zoom</code>值时其实也会发生重新渲染，运用这个原理，也就解决了<code>IE</code>下子元素浮动时父元素不随着自动扩大的问题。</p><p><code>zoom</code>属性是<code>IE</code>浏览器的专有属性，火狐和老版本的<code>webkit</code>核心的浏览器都不支持这个属性。然而，<code>zoom</code>现在已经被逐步标准化，出现在<code>CSS3.0</code>规范草案中。</p><p>目前<code>非IE</code>由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过<code>CSS3</code>里面的动画属性<code>scale</code>进行缩放。</p>`,22),d=[s];function t(l,n){return o(),i("div",null,d)}const p=e(a,[["render",t],["__file","清除浮动.html.vue"]]),k=JSON.parse('{"path":"/CSS/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html","title":"清除浮动","lang":"zh-CN","frontmatter":{"description":"清除浮动 需要清除浮动的原因 浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现为该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。 清除浮动是为了清除使用浮动元素产生的影响。...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/CSS/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"清除浮动"}],["meta",{"property":"og:description","content":"清除浮动 需要清除浮动的原因 浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现为该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。 清除浮动是为了清除使用浮动元素产生的影响。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-25T18:37:39.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-25T18:37:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"清除浮动\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-25T18:37:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"需要清除浮动的原因","slug":"需要清除浮动的原因","link":"#需要清除浮动的原因","children":[]},{"level":2,"title":"清除浮动的方式","slug":"清除浮动的方式","link":"#清除浮动的方式","children":[]},{"level":2,"title":"使用clear属性清除浮动的原理","slug":"使用clear属性清除浮动的原理","link":"#使用clear属性清除浮动的原理","children":[]},{"level":2,"title":"zoom:1清除浮动的原理","slug":"zoom-1清除浮动的原理","link":"#zoom-1清除浮动的原理","children":[]}],"git":{"createdTime":1723630143000,"updatedTime":1724611059000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":2}]},"readingTime":{"minutes":3.37,"words":1010},"filePathRelative":"CSS/清除浮动.md","localizedDate":"2024年8月14日","excerpt":"\\n<h2>需要清除浮动的原因</h2>\\n<p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现为该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“<code>高度塌陷</code>”。</p>\\n<p>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p>\\n<h2>清除浮动的方式</h2>\\n<ol>\\n<li>使用<code>clear</code>属性清除浮动。</li>\\n<li>使用<code>BFC</code>块级格式化上下文来清除浮动。</li>\\n</ol>","autoDesc":true}');export{p as comp,k as data};
