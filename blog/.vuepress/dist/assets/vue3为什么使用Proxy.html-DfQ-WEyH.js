import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,f as d}from"./app-8HN3oAmX.js";const t={},r=d('<h1 id="vue3为什么使用proxy" tabindex="-1"><a class="header-anchor" href="#vue3为什么使用proxy"><span><code>vue3</code>为什么使用<code>Proxy</code></span></a></h1><ol><li>更强大的功能：<code>Proxy</code>相比于<code>Object.defineProperty</code>拥有更多的功能和功能定制能力。<code>Proxy</code>可以拦截并定制目标对象上的各种操作，比如读取属性、修改属性、删除属性、调用函数等。而<code>Object.defineProperty</code>只能拦截对属性的读取和修改操作。</li><li>更好的性能：<code>Proxy</code>相比于<code>Object.defineProperty</code>有更好的性能。<code>Proxy</code>是在目标对象上建立一个代理，当对代理对象进行操作时，<code>Proxy</code>会直接拦截并处理，而不需要通过深入到目标对象的属性中。这使得<code>Proxy</code>的性能比<code>Object.defineProperty</code>更高。</li><li>更友好的错误提醒：<code>Proxy</code>可以提供更友好和明确的错误提示信息。当对代理对象进行非法操作时，<code>Proxy</code>会将错误信息直接抛出来，便于开发者更快地定位和解决问题。但<code>Object.defineProperty</code>只会在控制台输出警告信息。</li><li>更直观的语法：<code>Proxy</code>使用起来更加直观和简洁。比如对于一个数组，可以直接像访问数组一样去访问和修改代理对象的属性。而<code>Object.defineProperty</code>需要使用<code>vue</code>的<code>$set</code>或者<code>vue.set</code>方法来动态追踪属性的变化。</li><li>更好的扩展性：<code>Proxy</code>相比于<code>Object.defineProperty</code>有更好的扩展性。可以通过在<code>Proxy</code>上加入自定义的逻辑来满足更复杂的需求。<code>Proxy</code>还提供了一些附加的拦截方法，如<code>has</code>、<code>ownKeys</code>等，可以对目标对象进行更加精确的控制和操作。</li></ol><p>举个例子，假设有一个用户对象，需要在用户的姓名改变时更新一些<code>UI</code>。在<code>vue2</code>中，需要为这个对象的每个属性创建一个<code>getter</code>和<code>setter</code>，当属性被访问或修改时，我们可以执行一些额外的逻辑。但是这种方式在处理大对象或者嵌套对象时，性能会下降。</p><p>但在<code>vue3</code>中，可以直接用<code>Proxy</code>去包裹整个对象，当任何属性被访问或者修改时，都可以拦截到，而且还可以监视到新增或者删除属性的操作。这样无论对象有多大，或者有多深的嵌套，性能都可以保持在一个很高的水平。</p><p>使用<code>Object.defineProperty</code>的不足：</p><ul><li>动态创建的<code>data</code>属性需要用<code>vue.set</code>来赋值。</li><li>基于性能考虑，<code>vue2</code>篡改了数组的七个<code>API</code>。</li><li>需要提前递归地遍历<code>data</code>做到响应式。</li></ul><blockquote><p><code>Proxy</code>不兼容<code>IE</code>浏览器。</p></blockquote>',7),i=[r];function n(y,p){return c(),o("div",null,i)}const l=e(t,[["render",n],["__file","vue3为什么使用Proxy.html.vue"]]),x=JSON.parse('{"path":"/VUE/vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Proxy.html","title":"vue3为什么使用Proxy","lang":"zh-CN","frontmatter":{"description":"vue3为什么使用Proxy 更强大的功能：Proxy相比于Object.defineProperty拥有更多的功能和功能定制能力。Proxy可以拦截并定制目标对象上的各种操作，比如读取属性、修改属性、删除属性、调用函数等。而Object.defineProperty只能拦截对属性的读取和修改操作。 更好的性能：Proxy相比于Object.defin...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/VUE/vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Proxy.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"vue3为什么使用Proxy"}],["meta",{"property":"og:description","content":"vue3为什么使用Proxy 更强大的功能：Proxy相比于Object.defineProperty拥有更多的功能和功能定制能力。Proxy可以拦截并定制目标对象上的各种操作，比如读取属性、修改属性、删除属性、调用函数等。而Object.defineProperty只能拦截对属性的读取和修改操作。 更好的性能：Proxy相比于Object.defin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-20T06:06:03.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-20T06:06:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue3为什么使用Proxy\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-20T06:06:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1723794615000,"updatedTime":1724133963000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":1}]},"readingTime":{"minutes":2.16,"words":647},"filePathRelative":"VUE/vue3为什么使用Proxy.md","localizedDate":"2024年8月16日","excerpt":"\\n<ol>\\n<li>更强大的功能：<code>Proxy</code>相比于<code>Object.defineProperty</code>拥有更多的功能和功能定制能力。<code>Proxy</code>可以拦截并定制目标对象上的各种操作，比如读取属性、修改属性、删除属性、调用函数等。而<code>Object.defineProperty</code>只能拦截对属性的读取和修改操作。</li>\\n<li>更好的性能：<code>Proxy</code>相比于<code>Object.defineProperty</code>有更好的性能。<code>Proxy</code>是在目标对象上建立一个代理，当对代理对象进行操作时，<code>Proxy</code>会直接拦截并处理，而不需要通过深入到目标对象的属性中。这使得<code>Proxy</code>的性能比<code>Object.defineProperty</code>更高。</li>\\n<li>更友好的错误提醒：<code>Proxy</code>可以提供更友好和明确的错误提示信息。当对代理对象进行非法操作时，<code>Proxy</code>会将错误信息直接抛出来，便于开发者更快地定位和解决问题。但<code>Object.defineProperty</code>只会在控制台输出警告信息。</li>\\n<li>更直观的语法：<code>Proxy</code>使用起来更加直观和简洁。比如对于一个数组，可以直接像访问数组一样去访问和修改代理对象的属性。而<code>Object.defineProperty</code>需要使用<code>vue</code>的<code>$set</code>或者<code>vue.set</code>方法来动态追踪属性的变化。</li>\\n<li>更好的扩展性：<code>Proxy</code>相比于<code>Object.defineProperty</code>有更好的扩展性。可以通过在<code>Proxy</code>上加入自定义的逻辑来满足更复杂的需求。<code>Proxy</code>还提供了一些附加的拦截方法，如<code>has</code>、<code>ownKeys</code>等，可以对目标对象进行更加精确的控制和操作。</li>\\n</ol>","autoDesc":true}');export{l as comp,x as data};
