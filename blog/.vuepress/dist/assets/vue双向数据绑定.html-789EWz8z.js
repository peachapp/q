import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as c,f as t}from"./app-8HN3oAmX.js";const d={},r=t('<h1 id="vue双向数据绑定" tabindex="-1"><a class="header-anchor" href="#vue双向数据绑定"><span><code>vue</code>双向数据绑定</span></a></h1><ul><li><code>vue</code>双向数据绑定原理，又称<code>vue</code>响应式原理，是<code>vue</code>的核心，双向数据绑定是通过数据劫持结合发布者订阅者模式的方式（双向数据劫持+发布订阅模式）来实现的，通过<code>Object.defineProperty</code>来劫持各个属性的<code>setter</code>和<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。也就是说数据和视图同步，数据发生改变，视图跟着改变，视图改变，数据也随之发生改变。</li><li><code>vue</code>实现双向数据绑定的核心是<code>Object.defineProperty</code>方法。</li><li><code>Object.defineProperty(obj, prop, descriptor)</code>方法，接收三个参数，分别为：<code>obj</code>（定义其上属性的对象），<code>prop</code>（定义或修改的属性），<code>descriptor</code>（具体的改变方法），就是用这个方法来定义一个值，当调用时使用了它里面的<code>get</code>方法，当给这个属性赋值时，又用到了它里面的<code>set</code>方法。</li></ul><p>实现的具体步骤：</p><ol><li>需要<code>observer</code>的数据对象进行递归遍历，包括子属性对象的属性，都加上<code>setter</code>和<code>getter</code>。这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到数据变化。</li><li><code>compile</code>解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</li><li><code>watcher</code>订阅者是<code>observer</code>和<code>compile</code>之间通信的桥梁，主要做的事情是： <ul><li>在自身实例化时往属性订阅器 (<code>dep</code>) 里面添加自己。</li><li>自身必须有一个<code>update()</code>方法。</li><li>待属性变动<code>dep.notice()</code>通知时，能调用自身的<code>update()</code>方法，并触发<code>compile</code>中绑定的回调。</li></ul></li><li><code>MVVM</code>作为数据绑定的入口，整合<code>observer</code>、<code>compile</code>和<code>watcher</code>三者，通过<code>observer</code>来监听自己的<code>model</code>数据变化，通过<code>compile</code>来解析编译模板指令，最终利用<code>watcher</code>搭起<code>observer</code>和<code>compile</code>之间的通信桥梁，达到数据变化 --&gt; 视图更新、视图交互变化 (input) --&gt; 数据<code>model</code>变更的双向绑定效果。</li></ol><p><a href="https://www.jb51.net/article/206830.htm" target="_blank" rel="noopener noreferrer">实现：</a></p>',5),i=[r];function p(l,a){return c(),o("div",null,i)}const u=e(d,[["render",p],["__file","vue双向数据绑定.html.vue"]]),m=JSON.parse('{"path":"/VUE/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html","title":"vue双向数据绑定","lang":"zh-CN","frontmatter":{"description":"vue双向数据绑定 vue双向数据绑定原理，又称vue响应式原理，是vue的核心，双向数据绑定是通过数据劫持结合发布者订阅者模式的方式（双向数据劫持+发布订阅模式）来实现的，通过Object.defineProperty来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。也就是说数据和视图同步，数据发...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/VUE/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html"}],["meta",{"property":"og:site_name","content":"🍑的博客 ！"}],["meta",{"property":"og:title","content":"vue双向数据绑定"}],["meta",{"property":"og:description","content":"vue双向数据绑定 vue双向数据绑定原理，又称vue响应式原理，是vue的核心，双向数据绑定是通过数据劫持结合发布者订阅者模式的方式（双向数据劫持+发布订阅模式）来实现的，通过Object.defineProperty来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。也就是说数据和视图同步，数据发..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-20T06:06:03.000Z"}],["meta",{"property":"article:author","content":"🍑"}],["meta",{"property":"article:modified_time","content":"2024-08-20T06:06:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue双向数据绑定\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-20T06:06:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"🍑\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1723794615000,"updatedTime":1724133963000,"contributors":[{"name":"songzhichao","email":"caoxu@boyetrade.com","commits":1}]},"readingTime":{"minutes":1.91,"words":572},"filePathRelative":"VUE/vue双向数据绑定.md","localizedDate":"2024年8月16日","excerpt":"\\n<ul>\\n<li><code>vue</code>双向数据绑定原理，又称<code>vue</code>响应式原理，是<code>vue</code>的核心，双向数据绑定是通过数据劫持结合发布者订阅者模式的方式（双向数据劫持+发布订阅模式）来实现的，通过<code>Object.defineProperty</code>来劫持各个属性的<code>setter</code>和<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。也就是说数据和视图同步，数据发生改变，视图跟着改变，视图改变，数据也随之发生改变。</li>\\n<li><code>vue</code>实现双向数据绑定的核心是<code>Object.defineProperty</code>方法。</li>\\n<li><code>Object.defineProperty(obj, prop, descriptor)</code>方法，接收三个参数，分别为：<code>obj</code>（定义其上属性的对象），<code>prop</code>（定义或修改的属性），<code>descriptor</code>（具体的改变方法），就是用这个方法来定义一个值，当调用时使用了它里面的<code>get</code>方法，当给这个属性赋值时，又用到了它里面的<code>set</code>方法。</li>\\n</ul>","autoDesc":true}');export{u as comp,m as data};
