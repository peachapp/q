# `react`中的渲染流程

## 思路

- 宏观的设计理念。
- 关键原理清晰描述，抽象和具象相结合。
- 结合工程实践和工作成果。

## 设计理念

- 跨平台渲染 --> 虚拟`DOM`。
- 快速响应 --> 异步可中断 + 增量更新。

## 性能瓶颈

- `js`任务执行时间过长。
  - 浏览器刷新频率为`60Hz`，大概`16.6`毫秒渲染一次，而`js`线程和渲染线程是互斥的，所以如果`js`线程执行任务时间超过`16.6ms`的话，就会导致掉帧，导致卡顿，解决方案就是`react`利用空闲的时间进行更新，不影响渲染进行的线程。
  - 把一个耗时任务切分成一个个小任务，分布在每一帧里的方式就叫时间切片。

## 案例

- `concurrent-mode`。
- `concurrent-mode-adoption`。

## `react16+`的渲染流程

- `scheduler`：调度。选择高优先级的任务进入`reconciler`。
- `reconciler`：调和（是可中断的）。计算变更的内容。
- `react-dom`：提交。把变更的内容渲染到页面上。

## 屏幕刷新率

- 目前大多数设备的屏幕刷新频率为`60`次每秒。
- 浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。
- 页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿
- 每个帧的预算时间是 16.66 毫秒（1 秒 /60）。
- `1s60帧`，所以每一帧的时间是`1000/60≈16ms`，所以我们书写代码时力求不让一帧的工作量超过`16ms`。

## 帧

- 每个帧的开头包括样式计算、布局和绘制。
- `JavaScript`执行`javascript`引擎和页面渲染引擎在同一个渲染线程，`GUI`渲染和`javascript`执行两者是互斥的。
- 如果某个任务执行时间过长，浏览器会推迟渲染。

## requestIdleCallback

- 我们希望快速响应用户，让用户觉得够快，不能阻塞用户的交互。
- `requestIdleCallback`使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。
- 正常帧任务完成后没超过`16ms`说明时间有富余，此时就会执行`requestIdleCallback`里注册的任务。

## 同步写法，现在的官方版本，默认还是异步

`ReactDOM.render(<App />,document.getElementById('root'))`。

## 异步写法

`ReactDOM.unstable_createRoot(document.getElementById('root')).render(<App />)`。

## 如果申请的任务执行时间特别长，什么时候归还

这个是谁申请，谁决定什么时候归还（还钱），如果没归还，浏览器也没办法（合作式调度，君子协定）。

什么时候归还？

1. 任务完成了。
2. 本帧没有剩余时间了。

## 异步的写法缺陷或限制

异步写法反而把执行时间变长了（原来`50ms`就做完了，现在干`5ms`休息一下，时间就拉长了）。

## 如何确定一个任务的时长

一帧`16.6ms`，你的任务肯定不能超过`16.6ms`，浏览器它自己的工作大概需要`10ms`，所以留给你只有`5ms`。

**任务都分片了，每个任务都不是重新开始的，而是增量进行的。**

## 这种调度怎么兼容以前的生命周期

为了给异步操作让步，`componentWillMount` `componentWillUpdate` `componentWillReceiveProps`这三个生命周期被废弃了。

## `fiber`

- 我们可以通过某些调度策略合理分配`CPU`资源，从而提高用户的响应速度。
- 通过`fiber`架构，让自己的调和过程变成可被中断，适时地让出`CPU`执行权，可以让浏览器及时的响应用户的交互。
- `fiber`是一个执行单元，每次执行完一个执行单元，`react`就会检查现在还剩多少时间，如果没有时间就将控制权让出去。

## 默认的同步渲染，使用`fiber`了吗

默认的同步渲染，也使用了`fiber`，只不过没有暂停。
