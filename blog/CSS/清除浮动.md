# 清除浮动

## 需要清除浮动的原因

浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现为该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“`高度塌陷`”。

清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。

## 清除浮动的方式

1. 使用`clear`属性清除浮动。
2. 使用`BFC`块级格式化上下文来清除浮动。

因为`BFC`元素具有不会影响外部元素的特点，所以`BFC`元素也可以用来清除浮动的影响。因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违`BFC`元素的子元素不会影响外部元素的设定。

## 使用`clear`属性清除浮动的原理

使用`clear`属性清除浮动，其语法如下：

```css
clear: none|left|right|both;
```

如果单看字面意思，`clear: left;`应该是“清除左浮动”，`clear: right;`应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。

官方对`clear`属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置`clear`属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。

还需要注意的一点是`clear`属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“`前面的`”三个字，也就是`clear`属性对“后面的”浮动元素是不闻不问的。考虑到`float`属性要么是`left`，要么是`right`，不可能同时存在，同时由于`clear`属性对“后面的”浮动元素不闻不问，因此，当`clear: left;`有效的时候，`clear: right;`必定无效，也就是此时`clear: left;`等同于设置`clear: both;`同样地，`clear: right;`如果有效也是等同于设置`clear: both;`。由此可见，`clear: left;`和`clear: right;`这两个声明就没有任何使用的价值，至少在`CSS`世界中是如此，直接使用`clear: both;`吧。

一般使用伪元素的方式清除浮动：

```css
.clear::after {
  content: "";
  display: table; // 也可以是'block'，或者是'list-item'
  clear: both;
}
```

`clear`属性只有块级元素才有效的，而`::after`等伪元素默认都是行内元素，这就是借助伪元素清除浮动影响时需要设置`display`属性值的原因。

## `zoom:1`清除浮动的原理

清除浮动，触发`hasLayout`。

`zoom`属性可以设置或检索对象的缩放比例。解决`IE`下比较奇葩的`bug`。譬如外边距（`margin`）的重叠，浮动清除，触发`IE`的`hasLayout`属性等。

来龙去脉大概如下：当设置了`zoom`的值之后，所设置的元素就会扩大或者缩小，高度宽度就会重新计算，这里一旦改变`zoom`值时其实也会发生重新渲染，运用这个原理，也就解决了`IE`下子元素浮动时父元素不随着自动扩大的问题。

`zoom`属性是`IE`浏览器的专有属性，火狐和老版本的`webkit`核心的浏览器都不支持这个属性。然而，`zoom`现在已经被逐步标准化，出现在`CSS3.0`规范草案中。

目前`非IE`由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过`CSS3`里面的动画属性`scale`进行缩放。
