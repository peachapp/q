# `diff`算法

`diff`算法功能：提升性能。

虚拟`DOM`：就是数据（把`DOM`数据化）。

主流的`diff`算法：`snabbdom`、`virtual-dom`。

## 使用`snabbdom`

搭建环境：

```
npm init -y
cnpm install webpack@5 webpack-cli@3 webpack-dev-server@3 -S
cnpm install snabbdom -S
新建webpack.config.js
配置webpack.config.js
```

```js
// webpack.config.js
module.exports = {
  entry: "./src/index.js",
  output: {
    path: __dirname + "/public",
    filename: "./js/[name].js",
  },
  devServer: {
    contentBase: "./public",
    inline: true,
  },
};
```

`h函数`：用来生成虚拟`DOM`：

```js
h(
  "ul", // 节点名称
  {}, //
  // 内容（string）或子节点（array）
  "你好"
);

h(
  "ul", // 节点名称
  {}, //
  // 内容（string）或子节点（array）
  [
    h("li", { key: "a" }, "a"),
    h("li", { key: "b" }, "b"),
    h("li", { key: "c" }, "c"),
  ]
);
```

虚拟`DOM`：

```js
{
  children: undefined, // 子节点
  data: {},
  elm: h1, // 真实节点
  key: undefined,
  sel: 'h1', // 节点名称
  text: '你好' // 节点内容
}
```

真实节点：

```html
<h1>你好</h1>
```

新旧节点替换的规则（`patch`）：

1. 如果新旧节点不是同一个节点名称，那么就暴力删除旧的节点，创建插入新的节点。
2. 只能同层级比较，不能跨层级比较。如果跨层级，那么就暴力删除旧的节点，创建插入新的节点。
3. 如果是相同节点，又分为很多情况。判断新的节点有没有`children`：
   - 如果新的节点没有`children`，那就证明新节点是文本，直接把旧的替换成新的文本。
   - 如果新的节点有`children`，判断旧的节点有没有`children`：
     - 新的节点有`children`，旧的节点也有`children`。 --> 这就是`diff`算法的核心了。
       - 旧前 和 新前 \
         匹配：旧前的指针 ++，新前的指针 ++。
       - 旧后 和 新后 \
         匹配：旧后的指针 --，新后的指针 --。
       - 旧前 和 新后 \
         匹配：旧前的指针 ++，新后的指针 --。
       - 旧后 和 新前 \
         匹配：旧后的指针 --，新前的指针 ++。
       - 以上都不满足条件 --> 查找 \
         旧的指针不动，新的指针 ++，并且把新的添加到页面上，如果新的在旧的中能查找到，要给旧的中这个节点赋值成`undefined`。
       - 创建或者删除
     - 新的节点有`children`，旧的节点没有`children`。 --> 创建元素添加（把旧的内容删除清空掉，添加新的）。

注意：如果要提升性能，一定要加入`key`，`key`是唯一标识，在更改前后确认是不是同一个节点。

---

1. `vue`中的`diff`算法称为`patching`算法，它由`snabbdom`修改而来，虚拟`DOM`要想转化为真实`DOM`就需要通过`patch`方法转换。
2. 最初`vue1`视图中每个依赖均有更新函数对应，可以做到精准更新，因此并不需要虚拟`DOM`和`patching`算法支持，但是这样粒度过细导致`vue1`无法承载较大应用。`vue2`中为了降低`Watcher`粒度，每个组件只有一个`Watcher`与之对应，此时就需要引入`patching`算法才能精确找到发生变化的地方并高效更新。
3. `vue`中`diff`执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行`render`方法获得最新的虚拟`DOM`，然后执行`patch`方法，并传入新旧两次虚拟`DOM`，通过比对两者找到变化的地方，最后将其转化为对应的`DOM`操作。
4. `patch`过程是一个递归过程，遵循深度优先、同层比较的策略。以`vue3`的`patch`为例：
   - 首先判断两个节点是否为相同同类节点，不同则删除重新创建。
   - 如果双方都是文本则更新文本内容。
   - 如果双方都是元素节点则递归更新子元素，同时更新元素属性。
   - 更新子节点时又分了几种情况：
     - 新的子节点是文本，老的子节点是数组则清空，并设置文本。
     - 新的子节点是文本，老的子节点是文本则直接更新文本。
     - 新的子节点是数组，老的子节点是文本则清空文本，并创建新子节点数组中的子元素。
     - 新的子节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节。
5. `vue3`中引入的更新策略：编译期优化`patchFlags`、`block`等。
