<!-----
lang: zh-CN
title: js 面试
description: js 面试题收录
----->

## 判断数据类型？

**1. typeof**

使用 typeof 可以判断基本数据类型，null 除外。在使用 typeof 判断引用数据类型时除了判断 function 时返回 function 类型，其他引用类型返回的都是 object。并且返回的数据类型是字符串形式的小写。

使用方法：`typeof a`

返回格式为：string

**2. instanceof**

使用 instanceof 可以判断已知的引用数据类型、不能判断基本数据类型。instanceof 可以判断一个值是否属于某种类型、instanceof 也可以判断在继承时一个实例是否属于它的父类型。

使用方法：`[1,2,3,4] instanceof Array`

原理：获取目标类型的显式原型 prototype 以及需要判断的实例的隐式原型**proto**，将实例按原型链一级一级判断，直到**proto**为 null，代表已经到 Object 顶层对象，此时返回 false；若中途两者相等，则返回 true

> instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象原型链中的任何位置

instanceof 只有同一个全局 window，才会返回 true

```js
setTimeout(() => {
  // window.frames[0].arr iframe内部的数组
  console.log(window.frames[0].arr instanceof Array); // false
}, 1000);
```

**3. constructor**

constructor 是 prototype 对象上的属性，指向构造函数。constructor 除了 null 和 undefined 无法判断，其他的数据类型都可以判断，但是对于继承类型的数据有可能会出错、因为 Object 被覆盖掉了，检测结果就不对了。

使用方法：`([1,2,3,4]).constructor`

返回格式为：`ƒ Array() { [native code] }`

**4. Object.prototype.toString.call()**

Object.prototype.toString.call() 是通用于所有的数据类型，返回的是构造函数的类型。

使用方法：`Object.prototype.toString.call([1,2,3,4])`

返回格式为：`[object Array]`

**5. Array.isArray 可以判断是否是一个数组**

## 包装类？

JavaScript 的三个包装类

1. Number()
2. String()
3. Boolean()

**包装类可以将基本数据类型的数据转换成对象。**

为什么要转换成对象？

优点：因为对象有属性和方法，可以直接给对象设置属性，方便使用，对象的功能更强大。

不推荐这么使用，因为没有意义。

缺点：就算对象的值是相等的，如果是两个不同的对象，也是不相等的，这违反了常识，是错误的。

注意：\
在开发中，开发者基本都不会使用包装类，浏览器自动类型转换时才使用包装类的。\
如：当我们对一些基本数据类型的变量使用属性或方法时，浏览器会自动将基本数据转换成包装类，再调用包装类的方法。

## js 中的数组和函数在内存中时如何存储的？

js 中的数组存储大致需要分为 2 种情况：

- 同种类型数据的数组分配连续的内存空间
- 存在非同种类型数据的数组使用哈希映射分配内存空间

> 可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）

## 数组的原生方法？

1. concat：连接两个或多个数组，并返回已连接数组的副本。
2. slice：选择数组的一部分，并返回新数组。
3. toString：将数组转换为字符串，并返回结果。
4. join：将数组的所有元素连接成一个字符串。
5. pop：删除数组的最后一个元素，并返回该元素。
6. push：将新元素添加到数组的末尾，并返回新的长度。
7. shift：删除数组的第一个元素，并返回该元素。
8. unshift：将新元素添加到数组的开头，并返回新的长度。
9. reverse：反转数组中元素的顺序。
10. sort：对数组的元素进行排序。
11. splice：从数组中添加/删除/替换元素。
12. map：使用为每个数组元素调用函数的结果创建新数组。
13. forEach：为每个数组元素调用函数。
14. filter：使用数组中通过测试的每个元素创建新数组。
15. some：检查数组中的任何元素是否通过测试。
16. every：检查数组中的每个元素是否通过测试。

## forEach 和 map 区别？

**相同点**

1. 都是循环遍历数组中的每一项调用函数。
2. 每次执行函数都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）。
3. 只能遍历数组。

**不同点**

1. map() 会分配内存空间存储新数组并返回，forEach() 不会返回数据。
2. forEach() 允许 callback 更改原始数组的元素。map() 返回新的数组。

## arguments 是一个类数组对象，如何转成标准的数组？

类数组：与数组特征类似的对象（1. 拥有 length 属性，其属性（索引）为非负整数。2. 不具有数组的所具有的方法。）。

1. ...（扩展运算符）
2. Array.from
3. slice

## 数组合并？

1. for
2. concat
3. push.apply
4. 扩展运算符 (...)
5. push 和扩展运算符结合，push(...arr)

## 对象合并？

1. ... (扩展运算符)
2. Object.assign()

## 深拷贝和浅拷贝？

对象拷贝，简而言之就是将对象再复制一份，但是，复制的方法不同将会得到不同的结果。

深拷贝和浅拷贝主要是针对对象的属性是对象（引用类型）所提出的，对于基本数据类型不存在。

浅拷贝就是只拷贝一层。

深拷贝就不会像浅拷贝那样只拷贝一层，而是有多少层我就拷贝多少层，要真正的做到全部内容都放在自己新开辟的内存里。可以利用递归思想实现深拷贝。

浅拷贝：

- 扩展运算符（...）

深拷贝：

- JSON.parse(JSON.stringify()); 会丢失对象中的 undefined，对象，正则。
- 递归拷贝
- 工具库，如：lodash

## 基本数据类型和引用数据类型？

存储上：

- 基本数据类型是存放在栈中的简单数据段。
- 引用数据类型是存放在堆内存中的对象，在栈内存中存放的是堆内存中具体内容的引用地址，通过这个地址可以快速查找到对象。

比较上：

- 基本数据类型的比较是值的比较。直接比较值，看起来一样那么他们就是相等的。
- 引用数据 类型的比较是引用的比较。比较引用地址，也就是比较两个对象保存在栈区的指向堆内存的地址是否相同，虽然看起来一样，但是如果他们指向堆内存的地址是不一样的，那么两个对象也是不相等的。

赋值上：

- 基本数据类型的赋值是简单赋值。
- 引用数据类型的赋值是对象引用。

## 传值和传址？

js 赋值语句（=），就是把右边的数据/变量赋值给左边\
基本数据类型是传值\
引用数据类型是传址

```js
var user = {
  name: "小红",
};
function changeName(user) {
  // 方法内部的变量，先在方法内部找寻是否声明
  // 没有声明，再找寻形参
  // 没有形参，再找全局变量是否有声明
  // 没有声明，那就自动声明一个该全局变量
  user.name = "小明";
  user = {
    name: "小兰",
  };
}

changeName(user); // 方法执行的时候传参就是一个给形参变量赋值的一个过程
console.log(user.name); // 小明
```

## 事件捕获事件冒泡？

事件冒泡：事件由内到外触发（内层 div 事件 ->中间 div 事件 ->外层 div 事件）

事件捕获：事件由外到内触发（外层 div 事件 ->中间 div 事件 ->内层 div 事件）

**阻止事件冒泡：** `e.stopPropagation()` `window.event.cancelBubble = true`

顺序：先由外向内事件捕获，一直到事发元素，在由内向外冒泡到根节点上

## 事件委托（事件代理）？

“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown…）委托给父元素，让父元素担当事件监听的职务。

原理：利用 DOM 元素的事件冒泡机制。

**优点：**

- 提高 Javascript 性能，减少内存消耗
- 动态添加 DOM 元素，不需要因为元素的变动而修改事件绑定

**缺点：**

- 事件委托基于冒泡 , 对于不冒泡的事件不支持
- 层级过多，冒泡过程中，可能会被某层阻止掉
- 把所有事件都用代理就可能会出现事件误判，好比把不应该触发事件的 绑上了事件。

## 原型、原型链？

**什么是原型**

每一个 JavaScript 对象（除了 null ) 都具有的一个属性，叫**proto**，这个属性会指向该对象的原型（它的构造函数的 prototype 指向的对象）。

**什么是原型链**

每个对象都有一个原型**proto**，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，会先去这个对象里查找，如果没有的话就去它的原型对象里面查找，如果还是没有的话再去原型对象的原型对象里去查找。..... 这个操作被委托在整个原型链上，这个就是我们所说的原型链。

原型链的核心就是依赖对象的**proto**的指向，当查找自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到 Object 时，就没有**proto**指向了。

> 原型：函数的`prototype`属性，原型链：对象的`_proto_`属性

**原型链特点**

1. 就近原则，当要使用一个属性时，程序会优先查找离自己最近的，也就是自己有没有，如果自己没有，他就会沿着原型链向上查找，直到到达 Object。
2. 引用类型，当我们使用或者修改原型链上的属性时，其实使用的是同一个。
3. js 中每个函数都存在原型对象属性 prototype。并且所有函数的默认原型都是 Object 的实例。
4. 每个继承父函数的实例对象都包含一个内部属性**proto**。该属性包含一个指针，指向父函数的 prototype、若父函数的原型对象的**proto**属性为再上一层函数。在此过程中就形成了原型链。

**优点**

实现继承，简化代码，实现代码重用。

## 继承？

1. 原型链继承
2. 借用构造函数（经典继承），借助 call
3. 组合继承，原型链继承和经典继承双剑合璧（前 2 种组合）
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

## 作用域、作用域链？

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

作用域分为全局作用域、函数作用域、块级作用域。

**作用域、作用域链**

1. 作用域属于一个函数，一个函数产生了不一样的作用域
2. 函数名.[[scope]] 函数的隐式属性
3. [[scope]] 指的就是作用域，其中存储了运行期的上下文的集合，而这一集合就是作用域链
4. 查找变量：从作用域链的顶端依次向下查找（在那个函数里面查找变量，就上那个函数的作用域链的顶端依次向下查找变量）

**函数的执行期上下文**

1. 当函数执行的前一刻，会创建一个称为执行期上下文的内部对象 AO
2. 一个执行期上下文定义了一个函数执行时的环境（也就是函数预编译创建 AO 后下面的步骤操作），函数每次执行时对应的执行上下文都是独一无二的
3. 多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文会被销毁

**作用域和执行上下文之间最大的区别是：**

执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。

## 闭包？

闭包就是能够读取其他函数内部变量的函数。例如在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

作用：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理

优点：方便调用上下文中声明的局部变量、逻辑紧密，可以在一个函数中再创建个函数，避免了传参的问题

缺点：因为使用闭包，可以使函数在执行完后不被销毁，保留在内存中，如果大量使用闭包就会造成内存泄露，内存消耗很大

应用：防抖、节流

## 内存泄漏？哪些操作会导致内存泄漏？

内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

造成内存泄漏的操作：

- 意外的全局变量
- 闭包引起的内存泄漏
- 没有清理的 DOM 元素引用
- 被遗忘的定时器或者回调
- 子元素存在引起的内存泄漏
- 使用循环引用

## 防抖、节流？

防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案

区别在于：防抖函数只会在高频事件结束后一段时间调用一次函数，节流函数会在高频事件触发过程中每隔一段时间调用一次函数

**防抖： 触发高频事件一段时间后（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。**

```js
function debounce(func, wait) {
  let timeout = null;
  return function () {
    let context = this;
    let args = arguments;
    if (timeout) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(function () {
      func.apply(context, args);
    }, wait);
  };
}
```

防抖多用于

1.  用户输入用户名、手机号时，最后一个字母输入后再验证；
1.  一个按钮发送请求时，最后一次点击才发送；
1.  窗口 resize，当窗口确定大小时才渲染，防止重复渲染；
1.  输入框内容联想；

**节流：规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。**

```js
function throttle(func, wait) {
  let timeout = null;
  return function () {
    let context = this;
    let args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

节流多用于

滚动加载；mousemove ,mousehover。

## js 中的预解析？

js 引擎在运行一份代码的时候，会按照下面的步骤进行工作

1. 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值
2. 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用
3. 先提升 function，再提升 var

## 变量提升？

JavaScript 代码的执行分为两个阶段。第一个阶段在当前词法环境中注册所有的变量和函数声明，简单说就是，解析，解析完成之后，第二个阶段的 JavaScript 执行就开始了！

当 JavaScript 编译所有代码时，所有使用 var 的变量声明都被提升到它们的函数 / 局部作用域的顶部（如果在函数内部声明的话），或者提升到它们的全局作用域的顶部（如果在函数外部声明的话），而不管实际的声明是在哪里进行的。这就是我们所说的“提升”。这种“提升”实际上并不发生在代码中，而只是一种比喻，与 JavaScript 编译器如何读取代码有关。当我们想到“提升”的时候，我们可以想象任何被提升的东西都会被移动到作用域顶部，但是实际上的代码并不会被修改。

函数声明也会被提升，但是被提升到了最顶端，所以将位于所有变量声明之上。

## 暂时性死区？

> 当程序的控制流程在新的作用域进行实例化时，在此作用域中的 let/const 声明的变量，会先在作用域中创建出来，但此时还未在词法环境中进行注册（没有词法绑定），则此时是不能被访问的，访问就会报错。

> 从创建变量到可以被访问这一期间，叫做暂时性死区。

暂时性死区究其原因还是没有先声明后使用，解决办法就是要先声明后使用，否则就会引发暂时性死区。

暂时性死区的本质是：只要一进入当前作用域，所使用的变量就已经存在了，但是不可获取。只有等到 let、const 声明变量的那一行代码出现，才能获取和使用该变量。

- let、const、import、class、typeof 都会出现暂时性死区。
- var、function 不会出现暂时性死区。

## this？

在绝大数情况下，函数的调用方式决定了 this 值。this 不能在执行期间被复制，并且在每次函数被调用时 this 的值也可能会不同。

this 的值表示当前执行的环境对象，而与声明环境无关，所以 this 代表的对象要等函数运行才能确定。类似定义函数时的参数列表，只有在函数调用时才传入真正的对象。

this 关键字虽然会根据环境变化，但它始终代表的是调用当前函数的对象。

**this 一般有几种调用场景**

```
var obj = {a: 1, b: function(){console.log(this);}}
```

1. 作为对象调用时，指向该对象 `obj.b(); // 指向 obj`
2. 作为函数调用 `var b = obj.b; b(); // 指向全局 window`
3. 作为构造函数调用 `var b = new Fun(); // this 指向当前实例对象`
4. 作为 call 与 apply 调用 `obj.b.apply(object, []); // this 指向当前的 object`

## bind？

bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一系列参数将会在传递的实参前传入作为它的参数。（来自于 MDN )

## apply 和 call？

apply 和 call 最主要的作用，是改变 this 的指向。

共同点：都能够**改变函数执行时的上下文**，将一个对象的方法交给另一个对象来执行，并且是立即执行的。

区别：写法传参上`Function.call(obj,[param1[,param2[,…[,paramN]]]])` `Function.apply(obj[,argArray])`

**call**

- 调用 call 的对象，必须是个函数 Function。
- call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。
- 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

**apply**

- 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
- 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

## 箭头函数？

箭头函数`() => {}`允许我们用更短的语法定义函数。箭头函数可用于替代传统函数 `function() {}`。

规则：

1. 当函数参数只有一个时，括号可以省略，但是没有参数时，括号不可以省略。
2. 函数体（中括号）中有且只有一行 return 语句时，中括号及 return 关键字可以省略。

特点：

1. 箭头函数没有自己的 this 指向。
2. 不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。
3. 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
4. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

## 立即执行函数？

立即执行函数又名函数自调用，声明一个函数，并马上调用这个匿名函数就叫做立即执行函数；也可以说立即执行函数是一种语法，让你的函数在定义以后立即执行；

**写法：**

```js
// 用括号把整个表达式包起来
(function () {})();

// 用括号把函数包起来
(function () {})();

// 求反，不在意值是多少，只想通过语法检查
!(function () {})();

+(function () {})();

-(function () {})();

~(function () {})();
```

**作用：**

立即执行函数会创建一个独立的作用域，让外部无法访问作用域内部的变量，从而避免变量污染。并且该函数只会执行一次，执行后自动被垃圾回收。

**好处：**

1. 立即执行函数模式被广泛使用，它可以帮你封装大量的工作而不会在背后遗留任何全局变量。
2. 定义的所有变量都会成为立即执行函数的局部变量，所以不用担心这些临时变量会污染全局空间。
3. 这种模式经常被使用在书签工具 (bookmarklets) 中，因为书签工具在任何页面上运行并且保持全局命名空间干净是非常必要的。
4. 这种模式也可以让你将独立的功能封装在自包含模块中。
5. 可以将一些代码封装进一个立即执行函数中，并且确保页面没有它的情况下也能正常工作。
6. 可以添加更多的加强模块，移除它们，单独测试它们，允许用户去禁用它们等等。

## 柯里化？

**定义：**

柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。（维基百科）

柯里化可以将一个函数从可调用的 `f(a, b, c)` 转换为 `f(a)(b)(c)`

**好处：**

1. 让函数的职责单一
2. 复用参数逻辑

**性能问题**

1. 存取 arguments 对象通常要比存取命名参数要慢一点
2. 一些老版本的浏览器在 arguments.length 的实现上是相当慢的
3. 使用 fn.apply( … ) 和 fn.call( … ) 通常比直接调用 fn( … ) 稍微慢点
4. 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上

## v8 垃圾回收机制

https://juejin.cn/post/6844904016325902344

## 浮点数精度

https://github.com/mqyqingfeng/Blog/issues/155

## new 操作符？

实现步骤：

1. 创建一个新对象
2. 设置原型链 即 `obj._proto_ = 构造函数.prototype`
3. 让构造函数中的 this 指向 obj，执行构造函数（为这个新对象添加属性）
4. 返回新对象

用 js 模拟一个 new 函数

```js
function _new() {
  // 1. 创建一个对象
  let target = {};
  let [constructor, ...args] = [...arguments]; // 第一个参数是构造函数

  // 2. 原型链连接
  target.__proto__ = constructor.prototype;

  // 3. 将构造函数的属性和方法添加到这个新的空对象上
  let result = constructor.apply(target, args);
  if (result && (typeof result == "object" || typeof result == "function")) {
    // 如果构造函数返回的结果是一个对象，就返回这个对象
    return result;
  }
  // 如果构造函数返回的不是一个对象，就返回创建的新对象。
  return target;
}
let p2 = _new(Person, "小花");
console.log(p2.name); // 小花
console.log(p2 instanceof Person); // true
```

## new 一个箭头函数，会发生什么？

会报错，箭头函数不能作为构造函数，箭头函数没有 prototype 属性。

## generator？

Generator 顾名思义是生成器，使用 `function*` 语法和一个或多个 `yield` 表达式以创建一个函数即为生成器，它的返回值就是一个迭代器（即遍历器）。

它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。其实整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。

调用 Generator 函数，会返回一个内部指针 g（即遍历器 ）。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。

g.next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，这个对象就是具有两个属性（done (done=false) 和 value (value=operand)）的 IteratorResult 对象。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

**Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。**

## promise？

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理且更强大。它最早由社区提出并实现，ES6 将其写进了语言标准，统一了用法，并原生提供了 Promise 对象。

**特点**

对象的状态不受外界影响 （3 种状态）

- Pending 状态（进行中）
- Fulfilled 状态（已成功）
- Rejected 状态（已失败）

一旦状态改变就不会再变 （两种状态改变：成功或失败）

- Pending -> Fulfilled
- Pending -> Rejected

**用法**

Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

resolve 作用是将 Promise 对象状态由“未完成”变为“成功”，也就是 Pending -> Fulfilled，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；而 reject 函数则是将 Promise 对象状态由“未完成”变为“失败”，也就是 Pending -> Rejected，在异步操作失败时调用，并将异步操作的结果作为参数传递出去。

Promise 实例生成后，可用 then 方法分别指定两种状态回调参数。then 方法可以接受两个回调函数作为参数：

1. Promise 对象状态改为 Fulfilled 时调用 （必选）
2. Promise 对象状态改为 Rejected 时调用 （可选）

**优缺点**

| 优点     | 缺点                   |
| -------- | ---------------------- |
| 解决回调 | 无法监测进行状态       |
| 链式调用 | 新建立即执行且无法取消 |
| 减少嵌套 | 内部错误无法抛出       |

**promise 是干什么的？**

1. 主要用于异步计算
2. 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
3. 可以在对象之间传递和操作 promise，帮助我们处理队列

## Promise.all（只要失败一个就不会走 then）的解决方案？

1. try catch 包裹， 如果成功，调用 resolve，如果失败 catch 到错误，调用 Promise.resolve
2. Promise.allSettled

## Promise.all 和 Promise.allSettled？

- Promise.all 需要所有 promise 都成功时才 resolve 或者有一个失败时即 reject
- Promise.allSettled 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果

## 怎么让一个函数无论 promise 对象成功和失败都能被调用？

1. 在 finally 中调用这个函数
2. resolve 和 reject 中分别调用这个函数

## async await？

**async**

顾名思义，异步。async 函数是对 Generator 函数的改进，async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。特点体现在以下 4 点：

- 内置执行器
- 更好的语义
- 更广的适用性
- 返回值是 Promise

**await**

顾名思义，等待。正常情况下，await 命令后面是一个 Promise 对象，返回该对象的结果（可能是返回成功或者是返回失败的值）。如果不是 Promise 对象，就直接返回对应的值。另一种情况是，await 命令后面是一个 thenable 对象（即定义 then 方法的对象），那么 await 会将其等同于 Promise 对象。给人的感觉就像里面的操作是同步一样，但其本质 async 还是异步操作。

使用 async await 首先有两个条件

1. await 后面接一个会 return new promise 的函数并执行它
2. await 只能放在 async 函数里

async await 可以让异步代码看起来像同步代码，方便控制顺序

## async await 串行与并行

```js
// 线程休眠
function sleep(second) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(second);
    }, second);
  });
}

async function test() {
  console.log("1");
  await sleep(3000);
  console.log("2");
}

test();
```

```js
function sleep(second) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(Math.random());
      resolve(second);
    }, second);
  });
}
// 串行执行
async function chuanxing() {
  await sleep(2000);
  await sleep(2000);
  await sleep(2000);
}

// 并发执行
async function bingxing() {
  let tasks = [];
  for (let i = 0; i < 3; i++) {
    tasks.push(sleep(2000));
  }
  await Promise.all(tasks);
}

chuanxing();
bingxing();
```

## promise 和 async await 是为了解决什么问题？

promise 和 async/await 都是 es6 的新增特性，都是处理异步问题的好办法。

## setTimeout 和 promise 和 async await 的区别？

setTimeout 属于宏任务，Promise 里面的 then 方法属于微任务，async/await 中 await 后面紧跟的表达式是同步的，但接下来的代码是异步的，属于微任务。

**宏任务（macrotask）优先级：**

主代码块 > setImmediate > MessageChannel > setTimeout / setInterval

**微任务（microtask）优先级：**

process.nextTick > Promise = MutationObserver

Promise 本身是同步的，但在执行 resolve 或者 reject 时是异步的，即 then 方法是异步的。

## 事件循环机制（event loop）？

> js 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 web 浏览器。经过最近几年的发展，js 已经超出了浏览器的范围，进入了其他环境。\
> 所以这些环境都有一个共同“点”(thread, 也指线程）, 即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 js 引擎，这种机制被称为事件循环。

**event loop 主要分三部分：主线程、宏队列（macrotask）、微队列（microtask）**

js 的任务队列分为同步任务和异步任务，所有的同步任务都是在主线程里执行的，异步任务可能会在 macrotask 或者 microtask 里面。

**主线程**

> 就是访问到的 script 标签里面包含的内容，或者是直接访问某一个 js 文件的时候，里面的可以在当前作用域直接执行的所有内容（执行的方法、new 出来的对象）

**js 引擎的两大特点：单线程和非阻塞**

- 单线程：只有一个主线程来处理任务。
- 非阻塞：当执行异步任务时，不必等到结果返回，主线程会挂起 (pending) 这个任务，然后根据一定规则执行回调函数（事件循环机制）。

> JS 通常是非阻塞的，除了某些特殊情况，JS 会停止代码执行：
> alert, confirm, prompt（除了 Opera）。
> “页面上的程序正忙”的系统对话框弹出。

**任务分类：同步和异步**

- 同步任务：会立即执行的任务。
- 异步任务：不会立即执行的任务，可细分为宏任务和微任务。

> -- 宏任务：script, setTimeout, setInterval, setImmeditate, T/O, UI rendering \
> -- 微任务：process, nextTick, promise.then(), object.observe, MutationObserver

**执行顺序**

1. 先执行主线程
2. 遇到宏任务放到宏队列（macrotask）
3. 遇到微任务放到微队列（microtask）
4. 主线程执行完毕
5. 执行微队列（microtask），微队列（microtask）执行完毕
6. 执行一次宏队列（macrotask）中的一个任务，执行完毕
7. 执行微队列（microtask），执行完毕
8. 依次循环

**执行栈和任务队列**

栈内存和堆内存：栈内存保存着 JS 的变量和指向堆内存中对象的指针，堆内存保存着对象。

执行栈：

> 后进先出的数据结构，当函数被调用时添加到执行栈顶部，从栈顶移出。当一个任务为同步任务时，则会被立即执行，执行完移出；如果是异步任务，则会交给异步处理模块处理，当异步任务回调达到触发条件时，会将回调函数添加到任务队列中，如果是宏任务，则添加到宏任务队列中，如果是微任务，则添加到微任务队列中。

任务队列：

> 任务队列读取任务的顺序为宏任务 - 微任务（微任务队列全部执行结束才进入到下一轮宏任务）- 宏任务 - 微任务的顺序；当执行栈中的任务全部完成之后会从事件队列中读取一个任务添加到执行栈。一个任务队列中可以有多个宏任务队列，但只能有一个微任务队列。

引入微任务队列后，事实上事件循环执行的流程是这样的：

1. 一开始把一整段的 JS 脚本作为第一个宏任务执行
2. 在执行过程中，同步代码则直接运行，过程中存在宏任务则进入到宏任务队列，微任务则进入到微任务队列。
3. 在当前宏任务执行完成后，检查微任务队列，若存在微任务则按序全部执行完毕。
4. 继续检查宏任务队列，执行下一个宏任务，如此反复。

> 从规范来看，microtask （微任务）优先于 macrotask（宏任务） 执行，所以如果有需要优先执行的逻辑，放入 microtask 队列会比 task 更早的被执行。

## 进程和线程？

“进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源”

## ajax（Asynchronous JavaScript And Xml）？

基于 XML 的异步 JavaScript，简称 AJAX。

**五个步骤**

1. 创建一个 XMLHttpRequest 异步对象

```js
var xhr = new XMLHttpRequest();
```

2. 设置请求方式和请求地址

```js
// get请求如果有参数就需要在url后面拼接参数，
// post如果有参数，就在请求体中传递 xhr.open("get","validate.php?username="+name)
xhr.open("post", "validate.php");
```

3. 设置请求头：setRequestHeader()（GET 方式忽略此步骤）

```js
// 1.get不需要设置
// 2.post需要设置请求头：Content-Type:application/x-www-form-urlencoded
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
```

4. 向服务器发送请求

```js
// 1.get的参数在url拼接了，所以不需要在这个函数中设置
// 2.post的参数在这个函数中设置(如果有参数)
xhr.send(null) xhr.send("username="+name);
```

5. 让异步对象接收服务器的响应数据

一个成功的响应有两个条件：

1. 服务器成功响应了 。
2. 异步对象的响应状态为 4（数据解析完毕可以使用了）。

```js
xhr.onreadystatechange = function(){
if(xhr.status == 200 && xhr.readyState == 4){
 console.log(xhr.responseText);
}
```

**优点：**

1. 最大的优点就是页面无刷新，用户的体验非常好；
2. 使用异步方式与服务器通信，具有更加迅速的响应能力；
3. 可以把以前的一些服务器负担的工作转嫁到客户端，利用客户端限制的能力来处理，减轻服务器和带宽的负担，节约空间和带宽租用成本，并且减轻服务器的负担，Ajax 的原则是“按需取数据”，可以最大程度地减少冗余请求和响应对服务器造成的负担；
4. 基于标准化的并被广泛支持的技术，不需要下载插件和小程序；

**缺点：**

1. Ajax 不支持浏览器返回按钮；
2. 安全问题，Ajax 暴露了与服务器交互的细节；
3. 对搜索引擎的支持比较弱；
4. 破坏了程序的异常机制；
5. 不容易调试。

## 常见的请求方式有哪些？

1. GET： 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器；
2. POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式；
3. PUT： 传输文件，报文主体中包含文件内容，保存到对应 URI 位置；
4. HEAD： 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效；
5. DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件；
6. OPTIONS：查询相应 URI 支持的 HTTP 方法。

## 什么时候会发送 options 请求（预检请求）？

`OPTIONS请求`即预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。

触发 option 条件：

1. 前提是发生跨域请求
2. 触发一定条件，例如 post 请求的 Request headers 的 content-type 为 application/json
   注意：1. 必须是 request header ； 2.get 请求设置不了 content-type，因为 get 会把参数拼接在 url 上。

## get 和 post？

get 和 post 是表单提交数据的两种基本方式。

区别：

1. 功能不同 \
   get 是从服务器上获取数据。\
   post 是向服务器传送数据。
2. 过程不同 \
   get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。\
   post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址。用户看不到这个过程。
3. 获取值不同 \
   对于 get 方式，服务器端用 Request.QueryString 获取变量的值。\
   对于 post 方式，服务器端用 Request.Form 获取提交的数据。
4. 传送数据量不同 \
   get 传送的数据量较小，不能大于 2KB。\
   post 传送的数据量较大，一般被默认为不受限制。但理论上，IIS4 中最大量为 80KB，IIS5 中为 100KB。
5. 安全性不同 \
   get 安全性非常低。\
   post 安全性较高。

## fetch？

fetch 被称为下一代 Ajax 技术，采用 Promise 方式来处理数据。是一种简洁明了的 API，比 XMLHttpRequest 更加简单易用。

fetch 接受两个参数，url 和 init，其中 url 参数是必须的，而 init 参数是可选的。

## 跨域？

> 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。\
> 在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问问题。在请求的过程中我们要想获取数据一般都是 post/get 请求，所以就会出现跨域问题。

**什么是同源策略及其限制内容？**

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指"域名 + 端口 + 协议"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。

同源策略限制内容有：

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

**常见跨域场景**

当主域名、子域名、端口号、协议中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。

**解决**

1. 使用 ajax 的 jsonp。缺点：请求方式只能是 get 请求。
2. 使用 CORS。特点：前端代码和未处理跨域前一样，即普通的 ajax 请求，但服务器代码添加了一段解决跨域的代码。
3. 代理

https://juejin.cn/post/6844903767226351623#heading-11

## 从输入一个 url 到浏览器页面展示都经历了哪些过程？

一般会经历以下几个过程：

1. 首先，在浏览器地址栏中输入 url
2. 浏览器先查看浏览器缓存 - 系统缓存 - 路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3. 在发送 http 请求前，需要域名解析 (DNS 解析），解析获取相应的 IP 地址。
4. 浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手。
5. 握手成功后，浏览器向服务器发送 http 请求，请求数据包。
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到 HTTP 响应
8. 读取页面内容，浏览器渲染，解析 html 源码
9. 生成 Dom 树、解析 css 样式、js 交互
10. 客户端和服务器交互
11. ajax 查询

其中，步骤 2 的具体过程是：

浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；

操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的 DNS 查询缓存）；

路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；

ISP 缓存：若上述均失败，继续向 ISP 搜索。

https://juejin.cn/post/6935232082482298911

## 程序中捕获异常的方法？

- try catch
- Promise catch

## js 中如何将页面重定向到另一个页面？

1. 使用 location.href：window.location.href = "url";
2. 使用 location.replace：window.location.replace("url");

## forEach 如何跳出循环？

forEach 是不能通过`break`或者`return`来实现跳出循环到，为什么呢？forEach 的回调函数形成了一个作用域，在里面使用`return`并不会跳出，只会被当作`continue`。

可以利用`try catch`

```js
function getItemById(arr, id) {
  var item = null;
  try {
    arr.forEach(function (curItem, i) {
      if (curItem.id === id) {
        item = curItem;
        throw Error();
      }
    });
  } catch (e) {}
  return item;
}
```

## 移动端如何实现上拉加载，下拉刷新？

上拉加载：

上拉加载的本质是页面触底，或者快要触底时的动作

判断页面触底需要先了解一下下面几个属性

- scrollTop：浮动视窗的高度距离 window 顶部的距离，它会随着往上滚动而不断增加，初始值时 0，它是一个变化的值
- clientHeight：它是一个定值，表示屏幕可视区域的高度
- scrollHeight：页面不能滚动也是存在的，此时 scrollHeight 等于 clientHeight，scrollHeight 表示 body 所有元素的总长度（包括 body 元素自身的 padding）

下拉刷新：

下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作

关于下拉刷新的原生实现，主要分成三步：

- 监听原生 touchstart 事件，记录其初始位置的值，`e.touches[0].pageY`
- 监听原生 touchmove 事件，记录并计算当前滑动的位置值与初始位置值的差值，大于 0 表示向下拉动，并借助 css3 的`translateY`属性使元素随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值
- 监听原生 touchend 事件，若此时元素滑动达到最大值，则触发 callback，同时将`translateY`重设为 0，元素回到初始位置

```js
scrollTop + clientHeight >= scrollHeight;
```

## 一次渲染 10w 条数据？

- 分页 + setTimeout
- 分页 + requestAnimationFrame 可以减少重排的次数
- document.createDocumentFragment 文档碎片，是 dom 节点，不是主 dom 树的一部分。先创建一个文档碎片，遍历时将 dom 塞入文档碎片，最后将文档碎片塞入父节点

## 前端监控 SDK 技术要点

1. 可以通过`window.performance`获取各项性能指标数据
2. 完整的前端监控平台包括：数据采集和上报，数据整理和存储，数据展示
3. 网页性能指标：
   - FP（first-paint）：从页面加载到第一个像素绘制到屏幕上的时间
   - FCP（first-contentful-paint）：从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间
   - LCP（largest-contentful-paint）：从页面加载到最大文本或图像元素在屏幕上完成渲染的时间
4. 以上指标可以通过`PerformanceObserver`获取
5. 首屏渲染时间计算：通过`MutationObserver`监听`document`对象大属性变化

## CommonJS 模块和 ES6 模块区别？

**CommonJS 模块与 ES6 模块的区别**

1. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
2. CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。
3. CommonJS 是对模块的浅拷贝，ES6 Module 是对模块的引入，即 ES6 Module 只存只读，不能改变其值，具体点就是指针指向不能变，类似 const 。
4. import 的接口是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。

**CommonJS 模块与 ES6 模块的共同点**

1. CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进行改变。
