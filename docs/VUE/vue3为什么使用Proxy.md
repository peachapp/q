# `vue3`为什么使用`Proxy`

1. 更强大的功能：`Proxy`相比于`Object.defineProperty`拥有更多的功能和功能定制能力。`Proxy`可以拦截并定制目标对象上的各种操作，比如读取属性、修改属性、删除属性、调用函数等。而`Object.defineProperty`只能拦截对属性的读取和修改操作。
2. 更好的性能：`Proxy`相比于`Object.defineProperty`有更好的性能。`Proxy`是在目标对象上建立一个代理，当对代理对象进行操作时，`Proxy`会直接拦截并处理，而不需要通过深入到目标对象的属性中。这使得`Proxy`的性能比`Object.defineProperty`更高。
3. 更友好的错误提醒：`Proxy`可以提供更友好和明确的错误提示信息。当对代理对象进行非法操作时，`Proxy`会将错误信息直接抛出来，便于开发者更快地定位和解决问题。但`Object.defineProperty`只会在控制台输出警告信息。
4. 更直观的语法：`Proxy`使用起来更加直观和简洁。比如对于一个数组，可以直接像访问数组一样去访问和修改代理对象的属性。而`Object.defineProperty`需要使用`vue`的`$set`或者`vue.set`方法来动态追踪属性的变化。
5. 更好的扩展性：`Proxy`相比于`Object.defineProperty`有更好的扩展性。可以通过在`Proxy`上加入自定义的逻辑来满足更复杂的需求。`Proxy`还提供了一些附加的拦截方法，如`has`、`ownKeys`等，可以对目标对象进行更加精确的控制和操作。

举个例子，假设有一个用户对象，需要在用户的姓名改变时更新一些`UI`。在`vue2`中，需要为这个对象的每个属性创建一个`getter`和`setter`，当属性被访问或修改时，我们可以执行一些额外的逻辑。但是这种方式在处理大对象或者嵌套对象时，性能会下降。

但在`vue3`中，可以直接用`Proxy`去包裹整个对象，当任何属性被访问或者修改时，都可以拦截到，而且还可以监视到新增或者删除属性的操作。这样无论对象有多大，或者有多深的嵌套，性能都可以保持在一个很高的水平。

使用`Object.defineProperty`的不足：

- 动态创建的`data`属性需要用`vue.set`来赋值。
- 基于性能考虑，`vue2`篡改了数组的七个`API`。
- 需要提前递归地遍历`data`做到响应式。

> `Proxy`不兼容`IE`浏览器。
